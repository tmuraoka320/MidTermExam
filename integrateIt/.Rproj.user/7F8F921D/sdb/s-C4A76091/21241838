{
    "contents" : "#' Create an Object with class \"Trap\" or \"Simpson\"\n#'\n#' Create an instance with S4 class \"Trap\" or \"Simpson\"\n#'\n#'\n#' @param x A numeric vector x\n#' @param y A numeric vector y (= f(x))\n#' @param a A starting value\n#' @param b An ending value\n#' @param Trap A rule argument. If TRUE, the Trapezoidal rule is applied. If FALSE, the Simpson rule is applied. Defalt is TRUE.\n#'\n#'\n#' @return An object of class \"Trap\" or \"Simpson\" containing\n#'  \\item{x}{A vector of x}\n#'  \\item{y}{A vector of y}\n#'  \\item{result}{The result calculated by the Trapezoidal or Simpson rule}\n#'\n#' @author Taishi Muraoka \\email{tmuraoka@@wustl.edu}\n#'\n#' @examples\n#' myx <- 0:10\n#' myy <- cos(3*myx) + sin(2*sin(myx))\n#' mya <- 0\n#' myb <- 10\n#' integrateIt(myx, myy, mya, myb, Trap=TRUE)\n#' integrateIt(myx, myy, mya, myb, Trap=FALSE)\n#'\n#' @aliases integrateIt,ANY-method, plot,Trap-Simpson-method\n#'\n#' @rdname integrateIt\n#'\n#' @export\nsetGeneric(name=\"integrateIt\",\n           def=function(x, y, a, b, Trap=TRUE, ...){\n             standardGeneric(\"integrateIt\")\n           })\n\n#' @export\nsetValidity(\"Trap\", function(object){\n  if(is.numeric(object@x)==FALSE){ # check if x is a numeric\n    print(\"x should be a numeric vector!\")\n  }\n  if(is.numeric(object@y)==FALSE){ # check if y is numeric\n    print(\"y should be a numeric vector!\")\n  }\n  if(length(object@x) != length(object@y)){ # check if x and y have the same length\n    print(\"the length of x and y should be same!\")\n  }\n})\n\n#' @export\nsetMethod(\"integrateIt\",\n          definition=function(x, y, a, b, Trap=TRUE, ...){\n            # check if x and y are vectors\n            if(is.vector(x)==FALSE | is.vector(y)==FALSE){\n              stop(\"x and y should be a vector!\")\n            }\n            # check if x, y, a, and b are numeric\n            if(is.numeric(x)==FALSE | is.numeric(y)==FALSE |\n               is.numeric(a)==FALSE | is.numeric(b)==FALSE){\n              stop(\"x, y, a, and b should be numeric!\")\n            }\n            # check if x and y have the same length\n            if(length(x) != length(y)){\n              stop(\"the length of x and y vectors should be same!\")\n            }\n            # check if a and b have the length 1\n            if(length(a) != 1 | length(b) != 1){\n              stop(\"a and b should be length 1\")\n            }\n            subx <- x[which(x >= a & x <= b)] # limit the range of x to a-b\n            suby <- y[which(x >= a & x <= b)] # limit the range of y based on a-b\n            if(Trap==TRUE){ # if the Trapezoida rule is required\n              h2_part <- ((b-a)/(length(subx)-1))/2 # get (b-a)/n/2\n              sum_part <- sum(mapply(function(p,q){p*q},\n                                     p=suby, q=c(1, rep(2, length(suby)-2), 1))) # get the sum part\n              object <- new(\"Trap\", # create a new \"Trap\" object\n                            x=subx,\n                            y=suby,\n                            result=h2_part*sum_part)\n            }\n            else{ # if the Simpson rule is required\n              if(length(subx)%%2 != 1){ # check if subsetted x and y have odd length. If not give an error\n                stop(\"the length of x and y should be odd if you are to use the Simpson rule!\")\n              }\n              h3_part <- ((b-a)/(length(subx)-1))/3 # get (b-a)/n/3\n              sum_part <- sum(mapply(function(p,q){p*q},\n                                     p=suby, q=c(1, rep(c(4,2), (length(suby)-3)/2),\n                                                 4, 1))) # get the sum part\n              object <- new(\"Simpson\", # create a new \"Simpson\" object\n                            x=subx,\n                            y=suby,\n                            result=h3_part*sum_part)\n            }\n            return(object)\n          })\n\n#' @export\nsetMethod(\"plot\", \"Trap\",\n          function(x, y){\n            if(class(x)==\"Trap\"){ # if class is \"Trap\"\n              plot(x@x, x@y, type=\"n\",\n                   main=\"The Visual Result from the Trapezoidal Rule\",\n                   xlab=\"x\", ylab=\"f(x)\",\n                   xlim=c(min(x@x), max(x@x)), ylim=c(min(c(min(x@y), 0)),\n                                                      max(c(max(x@y), 0))))\n              polygon(c((seq(min(x@x), max(x@x), length.out=length(x@x))),\n                        rev(seq(min(x@x), max(x@x), length.out=length(x@x)))),\n                      c(rep(0, times=length(x@y)), rev(x@y)),\n                      border=NA, col=rgb(0,0.9,0.3,0.3)) # color the region of integration\n              mapply(function(p,q){segments(p, 0, p, q, lty=2, col=\"green4\")},\n                     p=x@x, q=x@y) # draw dotted lines of intervals\n              sapply(1:(length(x@x)-1),\n                     function(p){segments(x@x[p], x@y[p], x@x[p+1], x@y[p+1],\n                                          lwd=2, col=\"green4\")}) # draw straight lines connecting each interval\n              abline(h=0, lty=3) # draw a horizontal line at y=0\n            }\n            else{ # if class is \"Simpson\"\n              if(length(unique(sapply(1:(length(x@x)-1), # check if all intervals have the same length\n                                      function(p){x@x[p+1] - x@x[p]}))) != 1){\n                stop(\"the distance between two neighboring values should be same in x!\") # if the lengths of intervals differ, return this error\n              }\n              plot(x@x, x@y, type=\"n\",\n                   main=\"The Visual Result from the Simpson Rule\",\n                   xlab=\"x\", ylab=\"f(x)\",\n                   xlim=c(min(x@x), max(x@x)), ylim=c(min(c(min(x@y), 0)),\n                                                      max(c(max(x@y), 0))))\n              sapply(1:(length(x@x)-2), function(p){\n                u <- x@x[p] # get u\n                fu <- x@y[p] # get f(u)\n                v <- x@x[p+1] # get v\n                fv <- x@y[p+1] # get f(v)\n                w <- x@x[p+2] # get w\n                fw <- x@y[p+2] # get f(w)\n                seqx <- seq(u, w, by=0.01)\n                sval <- fu*(((seqx-v)*(seqx-w))/((u-v)*(u-w))) + # calculate p(x)\n                  fv*(((seqx-u)*(seqx-w))/((v-u)*(v-w))) +\n                  fw*(((seqx-u)*(seqx-v))/((w-u)*(w-v)))\n                polygon(c(seqx, rev(seqx)),\n                        c(rep(0, times=length(sval)), rev(sval)),\n                        border=NA, col=\"plum1\") # color the region of integration\n                lines(seqx, sval, lwd=2, col=\"darkviolet\") # draw a line of each parabola\n              })\n              mapply(function(p,q){segments(p, 0, p, q, lty=2, col=\"darkviolet\")},\n                     p=x@x, q=x@y) # draw dotted lines of intervals\n              abline(h=0, lty=3) # a horizontal line at y=0\n            }\n          })\n",
    "created" : 1458778276559.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "705781561",
    "id" : "21241838",
    "lastKnownWriteTime" : 1458780713,
    "path" : "~/MidTermExam/integrateIt/R/integrateIt.R",
    "project_path" : "R/integrateIt.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}